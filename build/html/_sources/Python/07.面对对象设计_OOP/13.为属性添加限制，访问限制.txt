# 为属性添加限制，访问限制

### 私有属性设置说明

    _foo        #protected 保护类型的成员，只允许类本身和子类可以访问，可以通过实例名称来访问.
            当 from modulename import * 时将不会引入以单下划线卡头的变量和函数
            单前置下划线,私有化属性或方法，禁止通过from modules import *导入,但是类对象和子类可以访问

    __foo       #使用类型的成员，只允许定义它类本身可以访问，不可以通过实例名称来访问，需要使用dir()查看后访问
    __foo__     #系统定义的名字，特殊的方法

#### 代码示例 1
```
class Swan:
    '''
    天鹅类
    '''
    _neck_swan = '天鹅的脖子很长'      #受保护类型的属性
    __neck_swan2 = '天鹅的脖子很长'      #私有类型的属性


    def __init__(self):
        print('这是构造方法中受到保护类型的属性', Swan.__neck_swan2)  #访问保护类型的属性

    def my(self):
        print("my方法: ", Swan.__neck_swan2)

swan = Swan()   #创建Swan类的实例(对象)
print('直接访问:', swan._neck_swan) #通过实例类型来访问受保护类型的属性

print()
swan1 = Swan()
print('私有类型的属性： ', swan1._Swan__neck_swan2)

swan1._Swan__neck_swan2 = "我修改了私有属性,天鹅的脖子很很很长"
print('修改私有属性后：',swan1._Swan__neck_swan2)

print()
swan1.my()      #修改的私有属性，在方法中不会生效

```

#### 代码示例 2
```
#!/usr/bin/env python
#-*- coding:utf8 -*-
'''
要让内部的属性不被外部直接访问
'''
class Person(object):
    def run(self):
        print("run")

    def eat(self,food):
        print("eat " + food)

    def __init__(self,name,age,height,weight,money,input_hu):
        self.name = name
        self.age = age
        self.height = height
        self.weight = weight
        self.__money = money  #此属性已经变为'_Person__money'
        self.__input__ = input_hu

    #通过内部的方法，去修改私有属性
    #通过自定义的方法实现对私有属性的赋值与取值
    def set_Money(self,money):
        #数据的过滤
        if money < 0:
            money = 0
        else:
            self.__money = money

    def get_Money(self):
        return self.__money

    def __del__(self):
        print("这里是析构函数")


per = Person("hujianli", 24, 180, 65,1000,"python")
print(dir(per))
print(dir(Person))
per.age = 18

#一般帅的人不这么使用，很不方便
per._Person__money = 22
print(per._Person__money)  #__money此时已经变成_Person__money了

#如果让内部属性不被外部直接访问，在属性前加__下划线
#如果在属性前加__下划线，那么这个属性就变成了私有属性,不能再实例化之后直接访问
# per.__money = 10


print(per.age)

print(per.get_Money())
print("开始赋值set_money" + " ====ing")
per.set_Money(100)
print("赋值之后的money是: {}".format(per.get_Money()))

#在python中__xxx___ 属于特殊变量，特殊变量的值可以直接访问
print("这是一个__xx__的特殊变量: %s" % per.__input__)

#一个下划线_xxx的变量，看到这样的变量时，表示当成私有属性，虽然可以直接在外部访问
#这是一个约定束城


```

### 私有属性的保护和设置
#### 代码示例 1
```
#!/usr/bin/env python
#-*- coding:utf8 -*-
class Duck():
    def __init__(self, input_name): #构造函数
        self.__name = input_name

    @property
    def name(self):
        print("inside the getter")
        return self.__name

    @name.setter
    def set_name(self,put_name):
        print("开始设置属性:name的值")
        self.__name = put_name



if __name__ == '__main__':
    name = "hujianli"
    hu = Duck(name)
    print(hu.name)
    print("分割线".center(100, "-"))
    hu.set_name = "xiaojian"
    print(hu.name)
    print()
    print(hu._Duck__name)

```

#### 代码示例 2
```
#!/usr/bin/env python
#-*- coding:utf8 -*-

#通过装饰器方法来获取私有属性
class TVShow:       #电视节目类
    list_film = ["战狼2", "红海行动", "西游记女儿国", "熊出没变形记"]

    def __init__(self, show):
        self.__show = show

    @property
    def show(self):
        '''
        定义方法
        :return:私有属性
        '''
        return self.__show      #返回类的实例

    @show.setter                #让属性可以进行修改
    def show(self, value):
        if value in TVShow.list_film:       #判断值是否在列表中
            self.__show = '您选择了《'+ value + "》,稍后将播放"    #修改返回值
        else:
            self.__show = "您点播的电影不存在"


tvshow = TVShow("战狼2")  #创建类的实例
print("正在播放:《", tvshow.show, "》")     #获取属性值
print("您可以从", TVShow.list_film, "中选择台点播的电影")

tvshow.show = '红海行动'
print(tvshow.show)      #获取属性值


'''
tvshow = TVShow("正在播放《战狼2》")  #创建类的实例
print("默认输出: ", tvshow.show)     #获取属性值

'''


#修改装饰器的值会报错
'''
tvshow.show = "正在播放《红海行动》"
print("默认输出: ", tvshow.show)     #获取属性值
'''

```