# 正则表达式

## 正则表达式语法

### 普通字符
    字母、数字、汉字、下划线、以及没有特殊定义的符号，都是"普通字符"。正则表达式中的普通字符，在匹配的时候，只匹配与自身相同的一个字符。
    例如：表达式c，在匹配字符串abcde时，匹配结果是：成功；匹配到的内容是c；匹配到的位置开始于2，结束于3。（注：下标从0开始还是从1开始，因当前编程语言的不同而可能不同）

### 元字符
    表达式	匹配
    .	    小数点可以匹配除了换行符\n以外的任意一个字符
    |	    逻辑或操作符
    []	    匹配字符集中的一个字符
    [^]	    对字符集求反，也就是上面的反操作。尖号必须在方括号里的最前面
    -	    定义[]里的一个字符区间，例如[a-z]
    \	    对紧跟其后的一个字符进行转义
    ()	    对表达式进行分组，将圆括号内的内容当做一个整体，并获得匹配的值

    例如：
    a.c匹配abc
    (a|b)c匹配ac与bc
    [abc]1匹配a1或者b1或者c1
    使用方括号[]包含一系列字符，能够匹配其中任意一个字符。用[^]包含一系列字符，则能够匹配其中字符之外的任意一个字符。
    [ab5@]匹配a或b或5或@
    [^abc]匹配a,b,c之外的任意一个字符
    [f-k]匹配f~k 之间的任意一个字母
    [^A-F0-3]匹配A~F以及0~3之外的任意一个字符

### 转义字符
    表达式	匹配
    \r, \n	匹配回车和换行符
    \t	匹配制表符
    \\	匹配斜杠\
    \^	匹配^符号
    \$	匹配$符号
    \.	匹配小数点.

### 预定义匹配字符集
    表达式	匹配
    \d	    任意一个数字，0~9 中的任意一个
    \w	    任意一个字母或数字或下划线，也就是 A~Z,a~z,0~9,_ 中的任意一个
    \s	    空格、制表符、换页符等空白字符的其中任意一个
    \D	    \d的反集，也就是非数字的任意一个字符，等同于[^\d]
    \W	    \w的反集，也就是[^\w]
    \S	    \s的反集，也就是[^\s]

    例如表达式\d\d，在匹配abc123时，匹配的结果是：成功；匹配到的内容是12；匹配到的位置开始于3，结束于5。
更多字符集匹配的详细内容可以参考
 <a href="https://www.jb51.net/tools/regexsc.htm" target="_blank">正则表达式速查表</a>
 <a href="https://www.jb51.net/tools/regex.htm" target="_blank">常用的正则表达式</a>
 <a href="http://shouce.jb51.net/py-re-guide/" target="_blank">python正则表达式操作指南</a>

### 重复匹配
    表达式	匹配
    {n}	    表达式重复n次，比如\d{2}相当于\d\d,a{3}相当于aaa
    {m,n}	表达式至少重复m次，最多重复n次。比如ab{1,3}可以匹配ab或abb或abbb
    {m,}	表达式至少重复m次，比如\w\d{2,}可以匹配a12,_1111,M123等等
    ?	    匹配表达式0次或者1次，相当于{0,1}，比如a[cd]?可以匹配a,ac,ad
    +	    表达式至少出现1次，相当于{1,}，比如a+b可以匹配ab,aab,aaab等等
    *	    表达式出现0次到任意次，相当于{0,}，比如\^*b可以匹配b,^^^b等等

    其中有些例子一定要注意！比如ab{1,3}中重复的是b而不是ab，(ab){1,3}这样重复的才是ab。表达式\^*b中重复的是\^而不是^，要从左往右读正则表达式，转义符号有更高的优先级，需要和后面的字符整体认读。
    表达式\d+\.?\d*在匹配It costs $12.5时，匹配的结果是：成功；匹配到的内容是12.5；匹配到的位置开始于10，结束于14。
    表达式go{2,8}gle在匹配Ads by goooooogle时，匹配的结果是：成功；匹配到的内容是goooooogle；匹配到的位置开始于7，结束于17。

### 位置匹配
    表达式	匹配
    ^	在字符串开始的地方匹配，符号本身不匹配任何字符
    $	在字符串结束的地方匹配，符号本身不匹配任何字符
    \b	匹配一个单词边界，也就是单词和空格之间的位置，符号本身不匹配任何字符
    \B	匹配非单词边界，即左右两边都是\w范围或者左右两边都不是\w范围时的字符缝隙


### 贪婪与非贪婪模式

    在重复匹配时，正则表达式默认总是尽可能多的匹配，这被称为贪婪模式。
    比如，针对文本dxxxdxxxd，表达式(d)(\w+)(d)中的\w+将匹配第一个d和最后一个d之间的所有字符xxxdxxx。

#### 举例说明
```
string = '''<table>
    <tr>
        <td>电视机</td>
        <td>冰箱</td>
        <td>空调</td>
    </tr>
</table>
'''
string = "".join(string.split())
re.search("<td>(.*)</td>",aa).group()
<td>电视机</td><td>冰箱</td><td>空调</td>

re.search("<td>\w+?</td>",aa).group()
'<td>电视机</td>
```
    我们的意图是获取每个<td></td>标签中的元素内容，
    如果你将正则表达式写成<td>(.*)</td>的话，你得到的是<td>电视机</td><td>冰箱</td><td>空调</td>这么个东西，而不是“电视机”、“冰箱”、“空调”。
    表达式<td>(.*?)</td>匹配上面的字符串时，将只得到<td>电视机</td>，再次匹配下一个时，可以得到<td>冰箱</td>，以此类推。贪婪匹配
    表达式<td>(\w+?)</td>为了让整个表达式匹配成功，\w+? 将尽可能少的匹配，从而使整个表达式匹配成功，实现非贪婪的匹配




## 正则表达式匹配模式
     方法	    描述	                     返回值
    compile(pattern[, flags])	根据包含正则表达式的字符串创建模式对象	re对象
    search(pattern, string[, flags])	在字符串中查找	第一个匹配到的对象或者None
    match(pattern, string[, flags])	在字符串的开始处匹配模式	在字符串开头匹配到的对象或者None
    split(pattern, string[, maxsplit=0,flags])	根据模式的匹配项来分割字符串	分割后的字符串列表
    findall(pattern, string,flags)	列出字符串中模式的所有匹配项	所有匹配到的字符串列表
    sub(pat,repl, string[,count=0,flags])	将字符串中所有的pat的匹配项用repl替换	完成替换后的新字符串
    finditer(pattern, string,flags)	将所有匹配到的项生成一个迭代器	所有匹配到的字符串组合成的迭代器
    subn(pat,repl, string[,count=0,flags])	在替换字符串后，同时报告替换的次数	完成替换后的新字符串及替换次数
    escape（string）	将字符串中所有特殊正则表达式字符串转义	转义后的字符串
    purge(pattern)	清空正则表达式
    template(pattern[,flags])	编译一个匹配模板	模式对象
    fullmatch(pattern, string[, flags])	match方法的全字符串匹配版本	类似match的返回值

```