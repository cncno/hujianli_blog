# 进程

### multiprocessing模块
```
multiprocessing模块是跨平台版本的多进程模块。Linux上支持os.fork()，windows上使用multiprocessing
multiprocessing模块提供了一个Process类来代表一个进程对象
```

```python
#!/usr/bin/env python
# -*- coding:utf8 -*-
'''
创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。

join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。

'''


from multiprocessing import Process
import os


# 子进程需要执行的代码
def run_proce(name):
    print("Run child process %s (%s)" % (name, os.getpid()))


if __name__ == '__main__':
    print("Parent process %s." % os.getpid())
    p = Process(target=run_proce, args=("test",))
    print("Child process will start.")
    p.start()
    p.join()
    print("Child process end.")
```




```python
import os
import multiprocessing


def foo(i):
    # 同样的参数传递方法
    print("这里是 ", multiprocessing.current_process().name)
    print('模块名称:', __name__)
    print('父进程 id:', os.getppid())  # 获取父进程id
    print('当前子进程 id:', os.getpid())  # 获取自己的进程id
    print('------------------------')


if __name__ == '__main__':

    for i in range(5):
        p = multiprocessing.Process(target=foo, args=(i,))
        p.start()
```

说明

* 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。

* join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。


### join()方法的使用
```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
from multiprocessing import Process
import time
import os

def child_1(n):
    print("子进程({})开始执行，它的父进程是({})".format(os.getpid(),os.getppid()))
    t_start = time.time()
    time.sleep(n)
    t_end = time.time()
    print("子进程（{}）执行时间为%0.2f秒".format(os.getpid(), t_end-t_start))


def child_2(n):
    print("子进程({})开始执行，它的父进程是({})".format(os.getpid(), os.getppid()))
    t_start = time.time()
    time.sleep(n)
    t_end = time.time()
    print("子进程（{}）执行时间为%0.2f秒".format(os.getpid(), t_end - t_start))




def main1():
    print("主进程开始")
    print("主进程的PID；{}".format(os.getpid()))
    p1 = Process(target=child_1, args=(1,))
    p2 = Process(target=child_2, args=(2,))
    p1.start()
    p2.start()
    print("p1.is_alive={}".format(p1.is_alive()))
    print("p2.is_alive={}".format(p2.is_alive()))
    print("p1.name={}".format(p1.name))
    print("p1.id={}".format(p1.pid))
    print("p2.name={}".format(p2.name))
    print("p2.id={}".format(p2.pid))
    #使用join函数之后，主进程会等待子进程结束之后才继续往下执行
    p1.join()
    p2.join()
    print("主进程结束..")


if __name__ == '__main__':
    main1()

```