# 线程
```
Python 的标准库提供了两个模块： _thread 和 threading ， _thread 是低级模块， threading 是高级模
块，对 _thread 进行了封装。绝大多数情况下，我们只需要使用 threading 这个高级模块。
```
```
启动一个线程就是把一个函数传入并创建 Thread 实例，然后调用 start() 开始执行：
 
```

### 多线程代码示例
```
#!/usr/bin/env python
# -*- coding:utf8 -*-
import threading
import time


# 新线程执行的代码

def loop():
    print("thread {} is running ....".format(threading.current_thread().name))
    n = 0
    while n < 5:
        n = n + 1
        print("thread {} >>> {}".format(threading.current_thread().name, n))
        time.sleep(1)
    print("thread {} ended".format(threading.current_thread().name))


print("thread {} is running ....".format(threading.current_thread().name))
t = threading.Thread(target=loop, name="Loopthread",)
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)

```

### 多线程通过类调用
```
import threading
import time
class MyThreading(threading.Thread):
    def __init__(self, conn):
        super(MyThreading, self).__init__()
        self.conn = conn
    def run(self):
        print('run task', self.conn)
        time.sleep(5)
t1 = MyThreading('t1')
t2 = MyThreading('t2')
t1.start()
t2.start()
```

### 线程同步
```
使用Thread对象的Lock和RLock可以实现简单的线程同步，
这两个对象都有acquire方法和release方法。
对于每次只允许一个线程操作的数据，可以将操作放到acquire和release方法之间。
多线程的优势在于可以同时运行多个任务，但当线程需要共享数据时，可能存在数据不同步的问题。 
考虑这样一种情况：一个列表里所有元素都是0，线程set从后向前把所有元素改成1，
而线程print负责从前往后读取列表并输出。

```
```python
#!/usr/bin/env python
#-*- coding:utf8 -*-
import threading
from time import sleep
from datetime import datetime

date_time_format = '%y-%M-%d %H:%M:%S'

class MyThread(threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter

    def run(self):
        print("开启线程：" + self.name)
        #获取锁，用于线程同步
        threadLock.acquire()

        print_time(self.name, self.counter, 3)
        
        #释放锁，开启下一个线程
        threadLock.release()


def date_time_str(date_time):
    return datetime.strftime(date_time, date_time_format)

def print_time(threadName, delay, counter):
    while counter:
        sleep(delay)
        print("{} {}".format(threadName, date_time_str(datetime.now())))
        counter -=1


def main():
    #创建新线程
    thread1 = MyThread(1, "Thread-1", 1)
    thread2 = MyThread(2, "Thread-2", 3)

    #开启新线程
    thread1.start()
    thread2.start()

    # 添加线程到线程列表
    threads.append(thread1)
    threads.append(thread2)

    #等待所有线程完成
    for t in threads:
        t.join()
    print("退出主线程.......")

if __name__ == '__main__':
    threadLock = threading.Lock()
    threads = []
    main()
```
